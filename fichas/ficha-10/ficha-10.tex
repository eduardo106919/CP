\documentclass[a4paper,11pt]{article}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{amsfonts}

\usepackage[twoside,verbose,body={16cm,24cm},
left=25mm,top=20mm]{geometry}


\title{Cálculo de Programas \\ Resolução - Ficha 10}
\author{Eduardo Freitas Fernandes}
\date{2025}

\setminted{
	frame=single,
	tabsize=4,
	breaklines=true
}



\begin{document}
	
	\maketitle
	
	\noindent \underline{\textbf{Exercício 1}}

	\[
	\begin{aligned}
		\xymatrix@C=2cm{
			A^*
			\ar@/^1pc/[r]^-{out}
			&
			1+A \times A^*
			\ar@/^1pc/[l]^-{in}
			\\
			A^*
			\ar[r]_-{g}
			\ar[u]^-{[\!(g)\!]}
			&
			1+A \times A^*
			\ar[u]_{id + id \times [\!(g)\!]}
		}
	\end{aligned}
	\]
	
	\noindent O anaformismo de g inverte uma lista, ou seja, é a função \texttt{reverse}.\\
	
	\noindent \underline{\textbf{Exercício 2}}
	\[
	\begin{aligned}
		\xymatrix@C=2cm{
			\mathbb{N}_0
			\ar@/^1pc/[r]^-{out}
			&
			1+ \mathbb{N}_0
			\ar@/^1pc/[l]^-{in}
			\\
			\mathbb{N}_0 \times \mathbb{N}_0
			\ar[r]_-{g}
			\ar[u]^-{\hat{\theta}}
			&
			1+ \mathbb{N}_0 \times \mathbb{N}_0
			\ar[u]_{id + \hat{\theta}}
		}
	\end{aligned}
	\]
	
	\[
	\begin{aligned}
		& g = \hat{(\leq)} \rightarrow i_1 \cdot (!), i_2 \cdot (id \times succ) \\
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 3}}
	\[
	\begin{aligned}
		& ................................................. \\
		\equiv \ &\{\text{Def. concat, Def. sum}\}\\
		& ................................................. \\
		\equiv \ &\{\text{Absorção-cata}\}\\
		& ................................................. \\
		\impliedby \ &\{\text{Absorção-+, Fusão-cata}\}\\
		& ................................................. \\
		\equiv \ &\{\text{Fusão-+, Absorção-+, Eq-+}\}\\
		& ................................................. \\
		\equiv \ &\{\text{Functor-$\times$}\}\\
		& ................................................. \\
		\equiv \ &\{\text{?????}\}\\
		& true \\
	\end{aligned}
	\]
	

	\noindent \underline{\textbf{Exercício 4}}
	\[
	\begin{aligned}
		& length = sum \cdot (map \ \underline{1}) \\
		\equiv \ &\{\text{Def. sum}\}\\
		& length = \llparenthesis \, [\underline{0}, add] \, \rrparenthesis \cdot map \ \underline{1} \\
		\equiv \ &\{\text{Absorção-cata}\}\\
		& length = \llparenthesis \, [\underline{0}, add] \cdot B \ (\underline{1}, id) \, \rrparenthesis \\
		\equiv \ &\{\text{Functor Base de listas}\}\\
		& length = \llparenthesis \, [\underline{0}, add] \cdot (id + \underline{1} \times id) \, \rrparenthesis \\
		\equiv \ &\{\text{Absorção-+}\}\\
		& length = \llparenthesis \, [\underline{0}, add \cdot (\underline{1} \times id)] \, \rrparenthesis \\
		\equiv \ &\{\text{ $ add \cdot (\underline{1} \times id) = succ \cdot \pi_2 $ }\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot \pi_2] \, \rrparenthesis \\
	\end{aligned}
	\]
	
	\noindent Podemos verificar que $ add \cdot (\underline{1} \times id) $ é equivalente a $ succ \cdot \pi_2 $, pois esta recebe um par de valores, destroi o primeiro (transformando no valor 1) e mantém o segundo, de seguida soma o segundo a 1, obtendo assim o valor equivalente ao seu sucessor.
	
	\[
	\begin{aligned}
		& length = length \cdot (map \ f) \\
		\equiv \ &\{\text{Def. length}\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot \pi_2] \, \rrparenthesis \cdot (map \ f) \\
		\equiv \ &\{\text{Absorção-cata}\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot \pi_2] \cdot B \ (f, id) \, \rrparenthesis \\
		\equiv \ &\{\text{Functor Base de listas}\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot \pi_2] \cdot (id + f \times id) \, \rrparenthesis \\
		\equiv \ &\{\text{Absorção-+, Natural-id}\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot \pi_2 \cdot (f \times id)] \, \rrparenthesis \\
		\equiv \ &\{\text{Natural-$\pi_2$}\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot id \cdot \pi_2] \, \rrparenthesis \\
		\equiv \ &\{\text{Natural-id}\}\\
		& length = \llparenthesis \, [\underline{0}, succ \cdot \pi_2] \, \rrparenthesis \\
	\end{aligned}
	\]
	
	
	\noindent \underline{\textbf{Exercício 5}}
	\[
	\begin{aligned}
		& depth \cdot LTree \ f = depth \\
		\equiv \ &\{\text{Def. depth}\}\\
		& \llparenthesis \, [one, succ \cdot umax] \, \rrparenthesis \cdot T_{LTree} \ f = depth \\
		\equiv \ &\{\text{Absorção-cata}\}\\
		& \llparenthesis \, [one, succ \cdot umax] \cdot B_{LTree} \ (f, id) \, \rrparenthesis = depth \\
		\equiv \ &\{\text{Functor Base de LTree}\}\\
		& \llparenthesis \, [one, succ \cdot umax] \cdot (f + (id \times id)) \, \rrparenthesis = depth \\
		\equiv \ &\{\text{Functor-id-$\times$, Absorção-+}\}\\
		& \llparenthesis \, [one \cdot f, succ \cdot umax \cdot id] \, \rrparenthesis = depth \\
		\equiv \ &\{\text{Fusão-const, Natural-id}\}\\
		& \llparenthesis \, [one, succ \cdot umax] \, \rrparenthesis = depth \\
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 6}}
	\[
	\begin{aligned}
		& bubble \ (x:y:xs) \\
		& \ \ \ | \ x > y = y : bubble \ (x:xs) \\
		& \ \ \ | \ otherwise = x : bubble \ (y:xs) \\
		& bubble \ x = x \\
		\implies \\
		& divide \ (x:y:xs) \\
		& \ \ \ | \ x > y = y \ ... \ (x:xs) \\
		& \ \ \ | \ otherwise = x \ ... \ (y:xs) \\
		& divide \ x = x \\
		\implies \\
		& divide \ (x:y:xs) \\
		& \ \ \ | \ x > y = i_2 \ (y, (x:xs)) \\
		& \ \ \ | \ otherwise = i_2 \ (x, (y:xs)) \\
		& divide \ x = i_1 \ x \\
	\end{aligned}
	\]
	
	\noindent Podemos então inferir o tipo da função \texttt{divide}:
	\[
	\begin{aligned}
		divide: A^* \rightarrow A^* + A \times A^*
	\end{aligned}
	\]
	\noindent Verificamos que o Functor Base necessário para formar este Hilomorfismo será o das \textbf{Listas com Sentinela}:
\begin{minted}{haskell}
data SList a b = Stl b | Cons a (SList a b)
\end{minted}
	\[
	\begin{aligned}
		\textbf{B} \, (Z,X,Y) = Z + X \times Y
	\end{aligned}
	\]
	
	\noindent Pelo tipo de \texttt{divide}, podemos inferir o tipo de \texttt{conquer}:
	\[
	\begin{aligned}
		& conquer: A^* + A \times A^* \rightarrow A^* \\
		& conquer = [id, cons]
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 7}}
	\[
	\begin{gathered}
		Point : a \to a \to a \to Point \ a \\
		\Downarrow \\
		uncurry \ Point : (a, a) \to a \to Point \ a \\
		\Downarrow \\
		uncurry \ \$ \ uncurry \ Point : ((a, a),a) \to Point \ a \\
		\Downarrow \\
		in = uncurry \ \$ \ uncurry \ Point \\
	\end{gathered}
	\]
	
	\newpage
	
	\noindent \underline{\textbf{Exercício 8}}
\begin{minted}{haskell}
module B_Tree where

import Cp

-- (1) Datatype definition

data B_Tree a = Nil | Block {leftmost :: B_Tree a, block :: [(a, B_Tree a)]}
	deriving (Show)

inB_Tree :: Either () (B_Tree a, [(a, B_Tree a)]) -> B_Tree a
inB_Tree = either (const Nil) (uncurry Block)

outB_Tree :: B_Tree a -> Either () (B_Tree a, [(a, B_Tree a)])
outB_Tree Nil = i1 ()
outB_Tree (Block l b) = i2 (l, b)

baseB_Tree g f = id -|- (f >< (map (g >< f)))

-- (2) Ana + cata + hylo

recB_Tree f = baseB_Tree id f

cataB_Tree g = g . (recB_Tree (cataB_Tree g)) . outB_Tree

anaB_Tree g = inB_Tree . (recB_Tree (anaB_Tree g)) . g

hyloB_Tree f g = cataB_Tree f . anaB_Tree g

-- (3) Map

instance Functor B_Tree where
fmap f = cataB_Tree (inB_Tree . baseB_Tree f id)

-- (4) Examples

-- (4.1) Count and depth

countB_Tree = cataB_Tree (either zero 
								(add . (id >< sum . map (succ . p2))))

depthB_Tree = cataB_Tree (either zero 
								(succ . umax . (id >< maximum . map p2)))

-- (4.2) Serialization 

-- in-order traversal
inordtB_Tree = cataB_Tree (either nil (conc . (id >< (concat . map cons))))

-- pre-order traversal
preordtB_Tree = cataB_Tree (either nil aux)
	where
		aux (l, []) = l
		aux (l, (h,a):t) = (h : l) ++ a ++ (concat (map cons t))

-- post-order traversal
postordtB_Tree = cataB_Tree (either nil (conc . (id >< (concat . map aux))))
	where
		aux (x, l) = l ++ [x]
\end{minted}
	
\end{document}