\documentclass[a4paper,11pt]{article}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{mathabx}
\usepackage{stmaryrd}
\usepackage[all]{xy}



\usepackage[twoside,verbose,body={16cm,24cm},
left=25mm,top=20mm]{geometry}


\title{Cálculo de Programas \\ Resolução - Ficha 09}
\author{Eduardo Freitas Fernandes}
\date{2025}

\setminted{
	frame=single,
	tabsize=4,
	breaklines=true
}


\begin{document}
	
	\maketitle
	
	\noindent \underline{\textbf{Exercício 1}}
	\[
	\begin{aligned}
		\xymatrix@C=2cm{
			LTree \ A
			\ar[d]_-{maximum}
			\ar@/^1pc/[r]^-{out}
			&
			A + (LTree \ A)^2
			\ar[d]^{id + (maximum)^2}
			\ar@/^1pc/[l]^-{in}
			\\
			A
			&
			A + A^2
			\ar[l]^-{[id, umax]}
		}
	\end{aligned}
	\]
	
	
	\[
	\begin{aligned}
	\xymatrix@C=2cm{
		BTree \ A
		\ar[d]_-{inorder}
		\ar@/^1pc/[r]^-{out}
		&
		1 + A \times (BTree \ A)^2
		\ar[d]^{id + id \times (inorder)^2}
		\ar@/^1pc/[l]^-{in}
		\\
		A^*
		&
		1 + A \times (A^*)^2
		\ar[l]^-{[nil, aux]}
	}
	\end{aligned}
	\]
	
	\[
	\begin{aligned}
	\xymatrix@C=4cm{
		BTree \ A
		\ar[d]_-{mirror}
		\ar@/^1pc/[r]^-{out}
		&
		1 + A \times (BTree \ A)^2
		\ar[d]^{id + id \times (mirror)^2}
		\ar@/^1pc/[l]^-{in}
		\\
		BTree \ A
		&
		1 + A \times (BTree \ A)^2
		\ar[l]^-{[\underline{Empty}, Node \cdot (id \times swap)]}
	}
\end{aligned}
\]
	
	\[
	\begin{aligned}
	\xymatrix@C=2cm{
		LTree \ A
		\ar[d]_-{rep \ a}
		\ar@/^1pc/[r]^-{out}
		&
		A + (LTree \ A)^2
		\ar[d]^{id + (rep \ a)^2}
		\ar@/^1pc/[l]^-{in}
		\\
		LTree \ A
		&
		A + (LTree \ A)^2
		\ar[l]^-{[\underline{a}, Fork]}
	}
\end{aligned}
\]
	
	\[
	\begin{aligned}
	\xymatrix@C=2cm{
		FTree \ B \ A
		\ar[d]_-{convert}
		\ar@/^1pc/[r]^-{out}
		&
		B + A \times (FTree \ B \ A)^2
		\ar[d]^{id + id \times convert^2}
		\ar@/^1pc/[l]^-{in}
		\\
		BTree \ A
		&
		B + A \times (BTree \ A)^2
		\ar[l]^-{[\underline{Empty}, Node]}
	}
\end{aligned}
\]
	
	\[
	\begin{aligned}
	\xymatrix@C=2cm{
		Expr \ V \ O
		\ar[d]_-{vars}
		\ar@/^1pc/[r]^-{out}
		&
		V + O \times (Expr \ V \ O)^*
		\ar[d]^{id + id \times map \ vars}
		\ar@/^1pc/[l]^-{in}
		\\
		V^*
		&
		V + O \times (V^*)^*
		\ar[l]^-{[singl, concat \cdot \pi_2]}
	}
\end{aligned}
\]
	
	
	\noindent \underline{\textbf{Exercício 2}}
	\[
	\begin{aligned}
		& tar = \llparenthesis \, [singl \cdot nil, g] \, \rrparenthesis \\
		\equiv \ &\{\text{Universal-cata}\}\\
		& tar \cdot [\underline{Empty}, Node] = [singl \cdot nil, g] \cdot (id + id \times (tar \times tar)) \\
		\equiv \ &\{\text{Fusão-+, Absorção-+}\}\\
		& [tar \cdot \underline{Empty}, tar \cdot Node] = [singl \cdot nil, g \cdot (id \times (tar \times tar))] \\
		\equiv \ &\{\text{Eq-+}\}\\
		&\begin{cases}
			tar \cdot \underline{Empty} = singl \cdot nil \\
			tar \cdot Node = g \cdot (id \times (tar \times tar))
		\end{cases}\\
		\equiv \ &\{\text{pointwise, Def. comp}\}\\
		&\begin{cases}
			tar \ Empty = [[]] \\
			tar (Node (x,(l,r))) = g \ (x, (tar \ l, tar \ r))
		\end{cases}\\
		\equiv \ &\{\text{Def. g}\}\\
		&\begin{cases}
			tar \ Empty = [[]] \\
			tar \ (Node (x,(l,r))) = (map \ cons \cdot lstr) (x, tar \ l ++ tar \ r)
		\end{cases}\\
		\equiv \ &\{\text{Def. comp, Def. lstr}\}\\
		&\begin{cases}
			tar \ Empty = [[]] \\
			tar \ (Node (x,(l,r))) = map \ cons [(x,a) | a \leftarrow tar \ l ++ \ tar \ r]
		\end{cases}\\
		\equiv \ &\{\text{Def. comp, Def. lstr}\}\\
		&\begin{cases}
			tar \ Empty = [[]] \\
			tar \ (Node (x,(l,r))) = [cons \ (h,t) | (h,t) \leftarrow [(x,a) | a \leftarrow tar \ l ++ \  tar \ r]]
		\end{cases}\\
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 3}}
	\[
	\begin{aligned}
		& vars = \llparenthesis \, [singl, concat \cdot \pi_2] \, \rrparenthesis \\
		\equiv \ &\{\text{Universal-cata}\}\\
		& vars \cdot [Var, Term] = [singl, concat \cdot \pi_2] \cdot (id + id \times map vars) \\
		\equiv \ &\{\text{Fusão-+, Absorção-+, Eq-+}\}\\
		&\begin{cases}
			vars \cdot Var = singl \\
			vars \cdot Term = concat \cdot \pi_2 \cdot (id \times map \ vars)
		\end{cases}\\
		\equiv \ &\{\text{Natural-$\pi_2$, pointwise}\}\\
		&\begin{cases}
			vars \ (Var v) = [v] \\
			vars \ (Term (o,l)) = concat \ (map \ vars \ l)
		\end{cases}
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 4}}
	\[
	\begin{aligned}
		& k = [\!((id + \langle f, id \rangle) \cdot out_{\mathcal{N}_0})\!] \\
		\equiv \ &\{\text{universal-ana}\}\\
		& out_* \cdot k = (id + id \times k) \cdot (id + \langle f, id \rangle) \cdot out_{\mathcal{N}_0} \\
		\equiv \ &\{\text{Shunt-left, Shunt-right}\}\\
		& k \cdot in_{\mathcal{N}_0} = in_* \cdot (id + id \times  k) \cdot (id + \langle f, id \rangle) \\
		\equiv \ &\{\text{Functor-+}\}\\
		& k \cdot [zero, succ] = [nil, cons] \cdot (id + (id \times k) \cdot \langle f, id \rangle) \\
		\equiv \ &\{\text{Absorção-$\times$, Absorção-+}\}\\
		& k \cdot [zero, succ] = [nil, cons \cdot \langle f, k \rangle] \\
		\equiv \ &\{\text{Fusão-+, Eq-+, pointwise}\}\\
		&\begin{cases}
			k \ 0 = [ \ ] \\
			k \ (n+1) = f \ n \ : \ k \ n
		\end{cases}
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 5}}
	\[
	\begin{aligned}
		& suffixes = [\!( (id + \langle cons, \pi_2 \rangle) \cdot out )\!] \\
		\equiv \ &\{\text{Universal-ana}\}\\
		& out \cdot suffixes = (id + id \times suffixes) \cdot (id + \langle cons, \pi_2 \rangle) \cdot out \\
		\equiv \ &\{\text{Shunt-left, Shunt-right}\}\\
		& suffixes \cdot in = in \cdot (id + id \times suffixes) \cdot (id + \langle cons, \pi_2 \rangle) \\
		\equiv \ &\{\text{Functor-+, Fusão-+}\}\\
		& [suffixes \cdot nil, suffixes \cdot cons] = [nil, cons] \cdot (id + ((id \times suffixes) \cdot \langle cons, \pi_2 \rangle )) \\
		\equiv \ &\{\text{Absorção-+}\}\\
		& [suffixes \cdot nil, suffixes \cdot cons] = [nil, cons \cdot ((id \times suffixes) \cdot \langle cons, \pi_2 \rangle )] \\
		\equiv \ &\{\text{Absorção-$\times$}\}\\
		& [suffixes \cdot nil, suffixes \cdot cons] = [nil, cons \cdot \langle cons,  suffixes \cdot \pi_2 \rangle] \\
		\equiv \ &\{\text{Eq-+, pointwise}\}\\
		&\begin{cases}
			suffixes \ [ \ ] = [ \ ] \\
			suffixes \ (h:t) = (h:t) : suffixes \ t
		\end{cases}
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 6}}
	\[
	\begin{aligned}
		& \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis = [\!( (id + \pi_2) \cdot out_* )\!] \\
		\equiv \ &\{\text{Universal-ana}\}\\
		& out_{\mathcal{N}_0} \cdot \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis = \textbf{F}_{\mathcal{N}_0} \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis \cdot (id + \pi_2) \cdot out_* \\
		\equiv \ &\{\text{Shunt-left, Shunt-right, Functor dos naturais}\}\\
		& \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis \cdot in_* = in_{\mathcal{N}_0} \cdot (id + \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis) \cdot (id + \pi_2) \\
		\equiv \ &\{\text{Functor-+, Def. in, Cancelamento-cata}\}\\
		& [zero, succ \cdot \pi_2] \cdot (id + id \times \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis) = [zero, succ] \cdot (id + \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis \cdot \pi_2) \\
		\equiv \ &\{\text{Absorção-+}\}\\
		& [zero, succ \cdot \pi_2 \cdot (id \times \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis)] = [zero, succ \cdot \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis \cdot \pi_2] \\
		\equiv \ &\{\text{Eq-+, Natural-$\pi_2$}\}\\
		&\begin{cases}
			zero = zero \\
			succ \cdot \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis \cdot \pi_2 = succ \cdot \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis \cdot \pi_2
		\end{cases}
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 7}}\\
\begin{minted}{haskell}
Data QTree a = Pixel a | Blocks ((QTree a, QTree a), (QTree a, QTree a))
	deriving (Show)

inQTree :: Either a ((QTree a, QTree a), (QTree a, QTree a)) -> QTree a
inQTree = either Pixel Blocks

outQTree :: QTree a -> Either a ((QTree a, QTree a), (QTree a, QTree a))
outQTree (Pixel x) = i1 x
outQTree (Blocks ((x, y), (z, w))) = i2 ((x, y), (z, w))

-- Bi-Functor de QTree
baseQTree g f = g -|- ((f >< f) >< (f >< f))

-- Functor de QTree
recQTree f = baseQTree id f

-- catamorfismo de QTree
cataQTree g = g . (recQTree (cataQTree g)) . outQTree

-- anamorfismo de QTree
anaQTree g = inQTree . (recQTree (anaQTRee g)) . g	

-- hylomorfismo de QTree
hyloQTree f g = cataQTree f . anaQTree g

instance Functor QTree where
	fmap f = cataQTree (inQTree . baseQTree f id)

mirrorQTree = cataQTree (either Pixel (Blocks . swap . (swap >< swap)))

countQTree = cataQTree (either one (add . (add >< add)))

depthQTree = cataQTree (either one (succ . umax . (umax >< umax)))

rotate90 = cataQTree (either Pixel (Blocks . f))
	where f ((x, y), (z, w)) = ((w, x), (y, z))

tips = cataQTree (either singl (conc . (conc >< conc)))
\end{minted}
	
	
\end{document}