\documentclass[a4paper,11pt]{article}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{minted}

\usepackage[twoside,verbose,body={16cm,24cm},
left=25mm,top=20mm]{geometry}


\title{Cálculo de Programas \\ Resolução - Ficha 01}
\author{Eduardo Freitas Fernandes}
\date{2025}

\setminted{
	frame=single,
	tabsize=4,
	breaklines=true
}


\begin{document}
	
\maketitle
	
\noindent \textbf{Exercício 1}
	
\begin{minted}{haskell}
length :: [a] -> Int
length [] = 0
length (x:xs) = 1 + length xs

reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]
\end{minted}

\noindent \textbf{Exercício 2}

\begin{minted}{haskell}
take m (take n x) = take (m `min` n) x
\end{minted}

\noindent \textbf{Exercício 3}

\begin{minted}{haskell}
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs

filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter f (x:xs) = if f x then x : filter f xs else filter f xs

uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y

curry :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x
\end{minted}

\newpage

\noindent \textbf{Exercício 4}

\[
\begin{cases}
	f \  x = 2 * x \\
	g \  x = x + 1
\end{cases}
(f \cdot g) \  x \overset{\text{(F1)}}{=} f (g \  x) = 2 * (x + 1)
\]

\begin{verbatim}
ghci> f x = 2 * x
ghci> g x = x + 1
ghci> (f . g) 5
12
\end{verbatim}
\[
\begin{cases}
	f \  x = succ \\
	g \  x = 2 * x
\end{cases}
(f \cdot g) \  x \overset{\text{(F1)}}{=} f (g \  x) = succ(2*x)
\]

\begin{verbatim}
ghci> f = succ
ghci> g x = 2 * x
ghci> (f . g) 5
11
\end{verbatim}
\[
\begin{cases}
	f \  x = succ \\
	g \  x = length
\end{cases}
(f \cdot g) \  x \overset{\text{(F1)}}{=} f (g \  x) = succ(length)
\]

\begin{verbatim}
ghci> f = succ
ghci> g = length
ghci> (f . g) [1..7]
8
\end{verbatim}
\[
\begin{cases}
	g \  (x,y) = x + y \\
	f = succ \cdot (2*)
\end{cases}
(f \cdot g) \  x \overset{\text{(F1)}}{=} f (g \  x) = succ (2 * (x + y))
\]

\begin{verbatim}
ghci> g (x,y) = x+y
ghci> f = succ . (2*)
ghci> (f . g) (3,5)
17
\end{verbatim}


\noindent \textbf{Exercício 5}

\[
\begin{aligned}
	(f \cdot g) \cdot h \  x
	\overset{\text{(F1)}}{=}& (f \cdot g)(h \  x) \\
	\overset{\text{(F1)}}{=}& f(g(h \  x)) \\
	\overset{\text{(F1)}}{=}& f ((g \cdot h) \  x) \\
	\overset{\text{(F1)}}{=}& f \cdot (g \cdot h) \  x
\end{aligned}
\]

\newpage

\noindent \textbf{Exercício 6}\\

\noindent Iremos assumir a seguite definição da função identidade:
\begin{minted}{haskell}
id :: a -> a
id x = x
\end{minted}
\[
\begin{aligned}
	f \cdot id \  x 
	\overset{\text{(F1)}}{=}& f(id \  x)
	\overset{\text{def. id}}{=}& f \  x
\end{aligned}
\]

\[
\begin{aligned}
	id \cdot f \  x 
	\overset{\text{(F1)}}{=}& id(f \  x)
	\overset{\text{def. id}}{=}& f \  x
\end{aligned}
\]

\noindent \textbf{Exercício 7}\\

\noindent \textbf{a)}
\[
\begin{aligned}
	store \  7 \  [1..10] &\overset{\text{(F2)}}{=} take \  10 \cdot nub \cdot 7:[1..10] \\
	&\overset{\text{(F1)}}{=} take \  10 \  (nub \  (7 : [1..10])) \\
	&\overset{\text{def. :}}{=} take \  10 \  (nub \  [7,1,2,3,4,5,6,7,8,9,10]) \\
	&\overset{\text{def. nub}}{=} take \  10 \  [7,1,2,3,4,5,6,8,9,10] \\
	&\overset{\text{def. take 10}}{=} [7,1,2,3,4,5,6,8,9,10] \\
\end{aligned}
\]

\[
\begin{aligned}
	store \  11 \  [1..10] &\overset{\text{(F2)}}{=} take \  10 \cdot nub \cdot 11:[1..10] \\
	&\overset{\text{(F1)}}{=} take \  10 \  (nub \  (11 : [1..10])) \\
	&\overset{\text{def. :}}{=} take \  10 \  (nub \  [11,1,2,3,4,5,6,7,8,9,10]) \\
	&\overset{\text{def. nub}}{=} take \  10 \  [11,1,2,3,4,5,6,7,8,9,10] \\
	&\overset{\text{def. take 10}}{=} [11,1,2,3,4,5,6,7,8,9] \\
\end{aligned}
\]

\noindent \textbf{b)} o requisito (a) é cumprido mas os restantes não, pois a primeira operação a ser feita é a remoção de duplicados. Esta operação deve ser feita após adicionar \texttt{c}. O requisito (b) não é cumprido, pois primeiro seleciona-se os 10 primeiros elementos e depois adiciona-se \texttt{c}, logo a lista final terá no máximo 11 elementos, violando o requisito (c).\\

\noindent \textbf{c)} o requisito (c) é violado, pois primeiro retira-se os primeiros 10 elementos e adiciona-se \texttt{c}, logo a lista final terá no máximo 11 elementos (caso a função \texttt{nub} não efetue mudanças na lista).\\

\noindent \textbf{Exercício 8}\\

\noindent O resultado será \texttt{["Mary","Manuel","Tia Irene","Augusto"]}. Neste exemplo é evidenciado o facto das funções en Haskell só receberem um argumento. Ao analisar a composição de funções em (F2):

\begin{itemize}
	\item \texttt{(c:) :: [a] -> [a]}
	\item \texttt{nub :: [a] -> [a]}
	\item \texttt{take 10 :: [a] -> [a]}
\end{itemize}

\noindent verificamos que a função \texttt{store} não recebe dois argumentos, recebe um argumento \texttt{c} e devolve uma função do tipo \texttt{store c :: [a] -> [a]}. Isto acontece porque Haskell aplica \textbf{currying} automaticamente.

\end{document}
