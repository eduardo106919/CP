\documentclass[a4paper,11pt]{article}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{amsfonts}

\usepackage[twoside,verbose,body={16cm,24cm},
left=25mm,top=20mm]{geometry}


\title{Cálculo de Programas \\ Resolução - Ficha 07}
\author{Eduardo Freitas Fernandes}
\date{2025}

\setminted{
	frame=single,
	tabsize=4,
	breaklines=true
}


\begin{document}
	
	\maketitle
	
	\noindent \underline{\textbf{Exercício 1}}\\
	
	\noindent \textbf{a)}
	
\begin{minipage}{0.47\textwidth}
\begin{minted}{haskell}
prod [] = 1
prod (h:t) = h * prod t
-- ou
prod = foldr (*) 1
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\[
prod = \llparenthesis \, [\underline{1}, mul] \, \rrparenthesis
\]	
\end{minipage}\\


\noindent \textbf{b)}

\begin{minipage}{0.47\textwidth}
\begin{minted}{haskell}
reverse [] = []
reverse (h:t) = reverse t ++ [h]
-- ou
reverse = foldr (flip (++) . singl)
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\[
	reverse = \llparenthesis \, [nil, conc \cdot swap \cdot (singl \times id)] \, \rrparenthesis
\]
\end{minipage}\\


\noindent \textbf{c)}

\begin{minipage}{0.47\textwidth}
\begin{minted}{haskell}
concat [] = []
concat (h:t) = h ++ concat t
-- ou
concat = foldr (++) []
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\[
	concat = \llparenthesis \, [nil, conc] \, \rrparenthesis
\]		
\end{minipage}\\


\noindent \textbf{d)}

\begin{minipage}{0.47\textwidth}
\begin{minted}{haskell}
map f [] = []
map f (h:t) = f h : map f t
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\[
	map \ f = \llparenthesis \, [nil, cons \cdot (f \times id )] \, \rrparenthesis
\]	
\end{minipage}\\


\noindent \textbf{e)}

\begin{minipage}{0.47\textwidth}
\begin{minted}{haskell}
maximum [x] = x
maximum (h:t) = max h (maximum t)
-- umax = uncurry max
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\[
	maximum = \llparenthesis \, [id, umax] \, \rrparenthesis
\]
\end{minipage}\\


\noindent \textbf{f)}

\begin{minipage}{0.47\textwidth}
\begin{minted}{haskell}
filter p [] = []
filter p (h:t) = x ++ filter p t
	where x = if (p h) 
			  then [h] 
			  else []
\end{minted}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\[
	filter \ p = \llparenthesis \, [nil, conc \cdot (p \rightarrow singl, nil) \times id] \, \rrparenthesis
\]
\end{minipage}\\


	\noindent \underline{\textbf{Exercício 2}}
	\[
	\begin{aligned}
		&sumprod \ a = (a*) \cdot sum \\
		\equiv \  &\{\text{Def. sum, Def. sumprod a}\}\\
		&\llparenthesis \, [zero, add \cdot ((a*) \times id)] \, \rrparenthesis = (a*) \cdot \llparenthesis \, [zero, add] \, \rrparenthesis \\
		\impliedby \  &\{\text{Fusão-cata}\}\\
		&(a*) \cdot [zero, add] = [zero, add \cdot ((a*) \times id)] \cdot (id + id \times (a*)) \\
		\equiv \  &\{\text{Fusão-+, Absorção-+}\}\\
		&[(a*) \cdot zero, (a*) \cdot add] = [zero, add \cdot ((a*) \times id) \cdot (id \times (a*))] \\
		\equiv \  &\{\text{Eq-+}\}\\
		&\begin{cases}
			(a*) \cdot zero = zero \\
			(a*) \cdot add = add \cdot ((a*) \times id) \cdot 
		\end{cases}\\
		\equiv \  &\{\text{Functor-$\times$}\}\\
		&\begin{cases}
			(a*) \cdot zero = zero \\
			(a*) \cdot add = add \cdot ((a*) \times (a*))
		\end{cases}\\
		\equiv \  &\{\text{pointwise, def. add, def. zero}\}\\
		&\begin{cases}
			a * 0 = 0 \\
			a * (x + y) = (a * x) + (a * y)
		\end{cases}
	\end{aligned}
	\]
	
	
	\noindent \underline{\textbf{Exercício 3}}
	\[
		length = \llparenthesis \, [zero, succ \cdot \pi_2] \, \rrparenthesis
	\]
	\[
	\begin{aligned}
		& f \cdot length = \llparenthesis \, [zero, (2+) . \pi_2] \, \rrparenthesis \\
		\equiv \ &\{\text{Def. length}\}\\
		& f \cdot \llparenthesis \, [zero, succ . \pi_2] \, \rrparenthesis = \llparenthesis \, [zero, (2+) . \pi_2] \, \rrparenthesis \\
		\impliedby \ &\{\text{Fusão-cata}\}\\
		& f \cdot [zero, succ \cdot \pi_2] = [zero, (2+) \cdot \pi_2] \cdot (id + id \times f) \\
		\equiv \ &\{\text{Fusão-+, Absorção-+, Natural-id}\}\\
		& [f \cdot zero, f \cdot succ \cdot \pi_2] = [zero, (2+) \cdot \pi_2 \cdot (id \times f)] \\
		\equiv \ &\{\text{Eq-+, Natural-$\pi_2$}\}\\
		&\begin{cases}
			f \cdot zero = zero \\
			f \cdot succ \cdot \pi_2 = (2+) \cdot f \cdot \pi_2
		\end{cases}\\
		\equiv \  &\{\text{pointwise}\}\\
		&\begin{cases}
			(f \cdot zero) \ n = zero \ n \\
			(f \cdot succ \cdot \pi_2) \ (x,y) = ((2+) \cdot f \cdot \pi_2) \ (x,y)
		\end{cases}\\
		\equiv \  &\{\text{Def. composição, Def. $\pi_2$}\}\\
		&\begin{cases}
			f \ 0 = 0 \\
			f \ (y+1) = 2 + f \ y
		\end{cases}\\
	\end{aligned}
	\]
	
	\noindent Sendo que $2+0 = 2$ e $2*0 = 0$, concluimos que $f = (2*)$.
	
	\newpage
	
	\noindent \underline{\textbf{Exercício 4}}
	\[
	\begin{aligned}
		& foldr \ \overline{\pi_2} \ i = f \\
		\equiv \  &\{\text{Def. foldr}\}\\
		& \llparenthesis \, [\underline{i}, uncurry \ curry \ \pi_2] \, \rrparenthesis = f \\
		\equiv \  &\{\text{Universal-cata}\}\\
		& f \cdot in = [\underline{i}, \pi_2] \cdot (id + id \times f) \\
		\equiv \  &\{\text{Def. in, Fusão-+, Absorção-+, Eq-+}\}\\
		&\begin{cases}
			f \cdot nil = \underline{i} \\
			f \cdot cons = \pi_2 \cdot (id \times f)
		\end{cases}\\
		\equiv \  &\{\text{pointwise}\}\\
		&\begin{cases}
			f \ [] = i \\
			f \ (h:t) = f \ t
		\end{cases}
	\end{aligned}
	\]
	
	\noindent Podemos concluir que $ foldr \ \overline{\pi_2} \ i $ é a função constante $i$.\\
	
	\noindent \underline{\textbf{Exercício 5}}
	\[
	\begin{aligned}
		&f \cdot (for \ f \ i) = for \ f (f \ i) \\
		\equiv \  &\{\text{Def. for b i}\}\\
		&f \cdot \llparenthesis \, [\underline{i}, f] \, \rrparenthesis = \llparenthesis \, [\underline{f \ i}, f] \, \rrparenthesis \\
		\impliedby \  &\{\text{Fusão-cata}\}\\
		&f \cdot [\underline{i}, f] = [\underline{f \ i}, f] \cdot (id + f) \\
		\equiv \  &\{\text{Fusão-+, Absorção-+}\}\\
		& [f \cdot \underline{i}, f \cdot f] = [\underline{f \ i} \cdot id, f \cdot f] \\
		\equiv \  &\{\text{Eq-+}\}\\
		&\begin{cases}
			f \cdot \underline{i} = \underline{f \ i} \\
			f \cdot f = f \cdot f
		\end{cases}\\
		\equiv \  &\{\text{Absorção-const}\}\\
		&\begin{cases}
			\underline{f \ i} = \underline{f \ i} \\
			f \cdot f = f \cdot f
		\end{cases}\\
	\end{aligned}
	\]
	
	
	\noindent \underline{\textbf{Exercício 6}}
	\[
	\begin{aligned}
		&for \ id \ i = for \underline{i} i \\
		\equiv \  &\{\text{Def. for (twice)}\}\\
		&\llparenthesis \, [\underline{i}, id] \, \rrparenthesis = \llparenthesis \, [\underline{i}, \underline{i}] \, \rrparenthesis \\
		\equiv \  &\{\text{Universal-cata}\}\\
		&\llparenthesis \, [\underline{i}, id] \, \rrparenthesis \cdot in = [\underline{i}, \underline{i}] \cdot (id + \llparenthesis \, [\underline{i}, id] \, \rrparenthesis) \\
		\equiv \  &\{\text{Cancelamento-cata, Absorção-+}\}\\
		& [\underline{i}, id] \cdot (id + \llparenthesis \, [\underline{i}, id] \, \rrparenthesis) = [\underline{i}, \underline{i}] \\
		\equiv \  &\{\text{Absorção-+}\}\\
		& [\underline{i}, \llparenthesis \, [\underline{i}, id] \, \rrparenthesis] = [\underline{i}, \underline{i}] \\
		\equiv \  &\{\text{Eq-+}\}\\
		&\begin{cases}
			\underline{i} = \underline{i} \\
			\llparenthesis \, [\underline{i}, id] \, \rrparenthesis = \underline{i}
		\end{cases}\\
		\equiv \  &\{\text{Universal-cata}\}\\
		&\begin{cases}
			true \\
			\underline{i} \cdot in = [\underline{i}, id] \cdot (id + \underline{i})
		\end{cases}\\
		\equiv \  &\{\text{Absorção-+}\}\\
		& \underline{i} = [\underline{i}, \underline{i}] \\
	\end{aligned}
	\]
	
	\noindent A última expressão é verdadeira, pois o resultado de $[\underline{i}, \underline{i}]$ será sempre $\underline{i}$.\\
	
	\noindent \underline{\textbf{Exercício 7}}
	
\begin{minted}{haskell}
ghci> rep f = cataNat (either (const id) (f.))
ghci> rep (2*) 0 3
3
ghci> rep ("a"++) 10 "b"
"aaaaaaaaaab"
\end{minted}
\[
\begin{aligned}
	\underline{id}:& \ B \rightarrow A^A \\
	f:& \ C \rightarrow D \\
	(f \cdot):& \ C^E \rightarrow D^E \\
\end{aligned}
\]

\noindent Temos de ter igualdade de tipos, ou seja:
\[
\begin{aligned}
	A^A = D^E \implies
	\begin{cases}
		A = E \\
		A = D
	\end{cases}
\end{aligned}
\]

\noindent Logo:
\[
\begin{aligned}
	\underline{id}:& \ B \rightarrow A^A \\
	f:& \ C \rightarrow A \\
	(f \cdot):& \ C^A \rightarrow A^A \\
\end{aligned}
\]


	\[
	\begin{aligned}
		\xymatrix@C=2cm{
			\mathbb{N}_0
			\ar[d]_-{rep \ f}
			\ar@/^1pc/[r]^-{out}
			&
			1 + \mathbb{N}_0
			\ar[d]^{id \, + \, rep \ f}
			\ar@/^1pc/[l]^-{in}
			\\
			A^A
			&
			1 + C^A
			\ar[l]^-{[\underline{id}, (f \cdot)]}
		}
	\end{aligned}
	\]
	
	\noindent \underline{\textbf{Exercício 8}}
	
\begin{minted}{haskell}
ghci> out 0 = i1 () ; out (n+1) = i2 n
ghci> cata g = g . (id -|- (cata g)) . out
ghci> rep a = cata (either nil (a:))
ghci> :t +d rep
rep :: a -> Integer -> [a]
ghci> rep 3 4
[3,3,3,3]
ghci> rep 'l' 8
"llllllll"
ghci> -- rep é a função que repete algo n vezes
\end{minted}
	
	\newpage
	
	\noindent \underline{\textbf{Exercício 9}}
	
\begin{minted}{haskell}
import Data.List (sort, nub)

type Date = String
type Player = String
type Game = String

db1 = [
	("2023-10-01", ["Game1", "Game2"]),
	("2023-10-02", ["Game2", "Game3"])
]

db2 = [
	("Game1", ["PlayerA", "PlayerB"]),
	("Game2", ["PlayerA", "PlayerC"]),
	("Game3", ["PlayerB", "PlayerC"])
]

f :: [(Date, [Game])] -> [(Game, [Player])] -> [(Player, [Date])]
f = undefined

main :: IO ()
main = do
	let result = f db1 db2
	print result
\end{minted}
	
\end{document}
